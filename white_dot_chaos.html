<!DOCTYPE html>
<html>
<head>
    <title>White Dot Chaos</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            user-select: none;
        }
        canvas { display: none; }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 10px;
            box-shadow: 0 4px #cc3333;
            transition: all 0.2s;
        }
        #startButton:hover {
            background-color: #ff6666;
            box-shadow: 0 2px #cc3333;
            transform: translate(-50%, -48%);
        }
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            display: none;
            color: #fff;
            z-index: 5;
            pointer-events: none;
        }
        #scoreBox {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #00ff00;
        }
        #shapeStats {
            position: absolute;
            top: 60px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            font-size: 18px;
        }
        #shapeFreqBar, #colorFreqBar {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px;
            border-radius: 5px;
        }
        #shapeFreqBar { top: 110px; left: 10px; }
        #colorFreqBar { top: 10px; right: 10px; }
        #modifiers {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 15px;
            font-size: 24px;
            pointer-events: auto;
        }
        #modifiers span {
            margin: 0 15px;
            cursor: pointer;
            padding: 5px 10px;
            background: #333;
            border-radius: 5px;
            transition: background 0.2s;
        }
        #modifiers span:hover { background: #555; }
        #helpButton, #settingsButton, #modeButton {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #fff;
            font-size: 30px;
            cursor: pointer;
            display: none;
            background: #444;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            transition: background 0.2s;
        }
        #settingsButton { bottom: 60px; font-size: 24px; }
        #modeButton { bottom: 110px; font-size: 24px; }
        #helpButton:hover, #settingsButton:hover, #modeButton:hover { background: #666; }
        #helpText, #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 20px;
            border-radius: 15px;
            max-width: 600px;
            display: none;
            z-index: 10;
            text-align: center;
            box-shadow: 0 0 20px #00ff00;
        }
        #helpCanvas {
            width: 100%;
            height: 100px;
            margin-top: 10px;
            border: 2px solid #00ff00;
            border-radius: 5px;
        }
        .shape-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 20px;
        }
        #settingsMenu label {
            display: block;
            margin: 10px 0;
            font-size: 18px;
        }
        #settingsMenu input[type="range"] { width: 100%; }
        #settingsMenu button {
            margin-top: 20px;
            padding: 10px 20px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        #settingsMenu button:hover { background: #ff6666; }
        #copyright {
            position: absolute;
            bottom: 10px;
            right: 60px;
            color: #fff;
            font-size: 14px;
            display: none;
        }
    </style>
</head>
<body>
    <button id="startButton">Start Adventure!</button>
    <canvas id="canvas"></canvas>
    <div id="gameUI">
        <div id="scoreBox">Score: 0</div>
        <div id="shapeStats">Top Shapes: </div>
        <div id="shapeFreqBar"><canvas id="shapeFreqCanvas" width="200" height="30"></canvas></div>
        <div id="colorFreqBar"><canvas id="colorFreqCanvas" width="200" height="30"></canvas></div>
    </div>
    <div id="modifiers">
        <span id="speedMod">üöÄ: 0</span>
        <span id="aimMod">üéØ: 0</span>
        <span id="shieldMod">üõ°Ô∏è: 0</span>
        <span id="growMod">üåü: 0</span>
        <span id="freezeMod">‚ùÑÔ∏è: 0</span>
    </div>
    <div id="helpButton">?</div>
    <div id="settingsButton">‚öôÔ∏è</div>
    <div id="modeButton">üéÆ</div>
    <div id="copyright">¬© Jamal Yusuf</div>
    <div id="helpText">
        <h2 style="color: #00ff00; text-shadow: 0 0 5px #00ff00;">The White Dot Saga</h2>
        <p>Command the White Dot in a wild universe of shapes! Burst through foes, snag modifiers, and rack up points!</p>
        <canvas id="helpCanvas"></canvas>
        <h3 style="color: #ff4444;">Rules</h3>
        <p><strong>White Dot:</strong> Speedy 20px+ hero with a 100px magnet. Click to spawn shapes!</p>
        <p><strong>Modes:</strong> Auto (moves itself) or Manual (mouse + WASD/arrows) via üéÆ button.</p>
        <p><strong>Objective:</strong> Smash shapes for points. 10 points = modifier; 100 points = spins!</p>
        <p><strong>Modifiers:</strong> Auto-used randomly or click to trigger!</p>
        <ul style="text-align: left; margin: 0 auto; display: inline-block;">
            <li><strong>üöÄ Speed Boost</strong> (Red): Zoom x3 (10s)</li>
            <li><strong>üéØ Aim Assist</strong> (Green): Blast within 200px (10s)</li>
            <li><strong>üõ°Ô∏è Shield</strong> (Blue): X-mark & wipe (10s)</li>
            <li><strong>üåü Growth</strong> (Yellow): Double size (10s)</li>
            <li><strong>‚ùÑÔ∏è Freeze</strong> (Cyan): Stop shapes (10s)</li>
        </ul>
        <p><strong>Shapes:</strong> Circles, squares, triangles (10-40px). Same merge (max 40px); others burst.</p>
        <p>Hit '?' to resume!</p>
    </div>
    <div id="settingsMenu">
        <h2 style="color: #00ff00; text-shadow: 0 0 5px #00ff00;">Settings</h2>
        <label>Shape Spawn Rate: <input type="range" id="spawnRate" min="0.01" max="0.1" step="0.01" value="0.03"></label>
        <label>White Dot Speed: <input type="range" id="heroSpeed" min="0.05" max="0.2" step="0.01" value="0.1"></label>
        <label>Mouse Sensitivity: <input type="range" id="mouseSensitivity" min="0.05" max="0.3" step="0.01" value="0.15"></label>
        <label>Max Shapes: <input type="range" id="maxShapes" min="10" max="50" step="5" value="20"></label>
        <button id="saveSettings">Save & Resume</button>
    </div>

    <script>
        // === Constants ===
        const SHAPE_TYPES = ['circle', 'square', 'triangle'];
        const MODIFIER_TYPES = ['üöÄ', 'üéØ', 'üõ°Ô∏è', 'üåü', '‚ùÑÔ∏è'];
        const MODIFIER_COLORS = {
            'üöÄ': '#ff0000', 'üéØ': '#00ff00', 'üõ°Ô∏è': '#0000ff', 'üåü': '#ffff00', '‚ùÑÔ∏è': '#00ffff'
        };

        // === Game State ===
        let gameState = {
            shapes: [],
            hero: null,
            explosions: [],
            flash: { timer: 0, color: 'rgba(255, 255, 255, 0)' },
            score: 0,
            activeModifiers: [],
            stats: { circle: 0, square: 0, triangle: 0 },
            colorCounts: {},
            modifierCounts: { 'üöÄ': 0, 'üéØ': 0, 'üõ°Ô∏è': 0, 'üåü': 0, '‚ùÑÔ∏è': 0 },
            animationFrameId: null,
            lastModifierTime: 0,
            mode: 'auto', // 'auto' or 'manual'
            mouseX: 0,
            mouseY: 0,
            keys: new Set(),
            settings: { spawnRate: 0.03, heroSpeed: 0.1, maxShapes: 20, mouseSensitivity: 0.15 }
        };

        // === DOM Elements ===
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startButton = document.getElementById('startButton');
        const gameUI = document.getElementById('gameUI');
        const scoreBox = document.getElementById('scoreBox');
        const shapeStats = document.getElementById('shapeStats');
        const shapeFreqCanvas = document.getElementById('shapeFreqCanvas');
        const shapeFreqCtx = shapeFreqCanvas.getContext('2d');
        const colorFreqCanvas = document.getElementById('colorFreqCanvas');
        const colorFreqCtx = colorFreqCanvas.getContext('2d');
        const modifiersDiv = document.getElementById('modifiers');
        const modifierButtons = {
            'üöÄ': document.getElementById('speedMod'),
            'üéØ': document.getElementById('aimMod'),
            'üõ°Ô∏è': document.getElementById('shieldMod'),
            'üåü': document.getElementById('growMod'),
            '‚ùÑÔ∏è': document.getElementById('freezeMod')
        };
        const helpButton = document.getElementById('helpButton');
        const settingsButton = document.getElementById('settingsButton');
        const modeButton = document.getElementById('modeButton');
        const copyright = document.getElementById('copyright');
        const helpText = document.getElementById('helpText');
        const settingsMenu = document.getElementById('settingsMenu');
        const helpCanvas = document.getElementById('helpCanvas');
        const helpCtx = helpCanvas.getContext('2d');
        const settingsInputs = {
            spawnRate: document.getElementById('spawnRate'),
            heroSpeed: document.getElementById('heroSpeed'),
            maxShapes: document.getElementById('maxShapes'),
            mouseSensitivity: document.getElementById('mouseSensitivity')
        };
        const saveSettingsButton = document.getElementById('saveSettings');

        // === Classes ===
        class Shape {
            constructor(isHero = false, isModifier = false, x = null, y = null) {
                this.x = x ?? Math.random() * canvas.width;
                this.y = y ?? Math.random() * canvas.height;
                this.isHero = isHero;
                this.isModifier = isModifier;
                this.type = this.assignType();
                this.size = isHero ? 20 : isModifier ? 15 : 10 + Math.random() * 30;
                this.maxSize = isHero ? 20 : 40;
                this.color = isHero ? '#ffffff' : isModifier ? '#ffffff' : `hsl(${Math.random() * 360}, 100%, 50%)`;
                this.health = isHero ? Infinity : this.size * 2;
                this.life = isHero ? Infinity : Math.random() * 600 + 400;
                this.age = 0;
                this.baseSpeed = isHero ? gameState.settings.heroSpeed : isModifier ? 0 : 0.03 + Math.random() * 0.06;
                this.speed = this.baseSpeed;
                this.vx = 0; // Velocity X for manual mode
                this.vy = 0; // Velocity Y for manual mode
                this.targetX = isModifier ? this.x : this.newTarget('x');
                this.targetY = isModifier ? this.y : this.newTarget('y');
                this.trail = isHero ? [] : null;
                this.modifierColor = isModifier ? MODIFIER_COLORS[this.type] : null;
                this.marked = false;
                this.rotation = 0;
                this.charging = false;
            }

            assignType() {
                if (this.isHero) return 'circle';
                if (this.isModifier) return MODIFIER_TYPES[Math.floor(Math.random() * MODIFIER_TYPES.length)];
                return SHAPE_TYPES[Math.floor(Math.random() * SHAPE_TYPES.length)];
            }

            newTarget(axis) {
                const range = axis === 'x' ? canvas.width : canvas.height;
                return range * 0.1 + Math.random() * range * 0.8;
            }

            update() {
                this.applyModifiers();
                if (this.isHero) {
                    gameState.mode === 'auto' ? this.updateAuto() : this.updateManual();
                } else if (!this.isModifier) {
                    this.updateShape();
                }
                this.move();
                this.age++;
                if (this.isHero) this.updateTrail();
            }

            applyModifiers() {
                this.speed = gameState.activeModifiers.some(mod => mod.type === '‚ùÑÔ∏è') && !this.isHero && !this.isModifier ? 0 : this.baseSpeed;
                if (this.isHero) {
                    this.size = gameState.activeModifiers.some(mod => mod.type === 'üåü') ? 40 : 20;
                    if (gameState.activeModifiers.some(mod => mod.type === 'üöÄ')) this.speed = this.baseSpeed * 3;
                }
            }

            updateAuto() {
                const nearest = gameState.shapes.find(s => s.isModifier && this.distanceTo(s) < 200);
                if (nearest) {
                    this.targetX = nearest.x;
                    this.targetY = nearest.y;
                } else if (this.distanceTo({ x: this.targetX, y: this.targetY }) < 15) {
                    this.targetX = this.newTarget('x');
                    this.targetY = this.newTarget('y');
                }
            }

            updateManual() {
                const dx = gameState.mouseX - this.x;
                const dy = gameState.mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Adjustable sensitivity from settings (default 0.15, range 0.05 to 0.3)
                const mouseSensitivity = gameState.settings.mouseSensitivity || 0.15;
                const baseSpeed = this.speed * 100; // Adjusted for smoother movement

                // Easing factor for smooth movement (0 to 1, closer to 1 = snappier)
                const easing = 0.1;

                // Calculate target velocity with easing
                if (distance > 5) { // Small deadzone to prevent jitter
                    this.vx += (dx / distance) * baseSpeed * mouseSensitivity * easing;
                    this.vy += (dy / distance) * baseSpeed * mouseSensitivity * easing;
                }

                // Optional keyboard boost (increases speed temporarily)
                const boostFactor = gameState.keys.size > 0 ? 1.5 : 1; // 50% speed boost with keys
                if (gameState.keys.has('arrowup') || gameState.keys.has('w')) this.vy -= this.speed * 20 * boostFactor;
                if (gameState.keys.has('arrowdown') || gameState.keys.has('s')) this.vy += this.speed * 20 * boostFactor;
                if (gameState.keys.has('arrowleft') || gameState.keys.has('a')) this.vx -= this.speed * 20 * boostFactor;
                if (gameState.keys.has('arrowright') || gameState.keys.has('d')) this.vx += this.speed * 20 * boostFactor;

                // Apply drag for smoother deceleration
                const drag = 0.9;
                this.vx *= drag;
                this.vy *= drag;

                // Cap max speed to prevent overshooting
                const maxSpeed = baseSpeed * boostFactor;
                const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (currentSpeed > maxSpeed) {
                    const scale = maxSpeed / currentSpeed;
                    this.vx *= scale;
                    this.vy *= scale;
                }
            }

            updateShape() {
                if (!gameState.hero) return;
                const distance = this.distanceTo(gameState.hero);
                if (distance < gameState.hero.size * 5) {
                    const pull = (1 - distance / (gameState.hero.size * 5)) * 0.05;
                    this.x += (gameState.hero.x - this.x) * pull;
                    this.y += (gameState.hero.y - this.y) * pull;
                }
                if (this.distanceTo({ x: this.targetX, y: this.targetY }) < 5 && Date.now() - this.age > 1000) {
                    this.charging = true;
                    this.targetX = gameState.hero.x;
                    this.targetY = gameState.hero.y;
                    this.speed *= 2;
                    this.rotation += 0.1;
                } else {
                    this.charging = false;
                }
                if (gameState.score >= 100) this.rotation += 0.05 * Math.floor(gameState.score / 100);
            }

            move() {
                if (this.isHero && gameState.mode === 'manual') {
                    this.x += this.vx;
                    this.y += this.vy;
                    // Keep within bounds
                    this.x = Math.max(this.size, Math.min(canvas.width - this.size, this.x));
                    this.y = Math.max(this.size, Math.min(canvas.height - this.size, this.y));
                } else if (!this.isModifier) {
                    this.x += (this.targetX - this.x) * this.speed + (Math.random() - 0.5) * 2;
                    this.y += (this.targetY - this.y) * this.speed + (Math.random() - 0.5) * 2;
                }
            }

            updateTrail() {
                const speedFactor = gameState.mode === 'manual' 
                    ? Math.sqrt(this.vx * this.vx + this.vy * this.vy) / 10 
                    : this.speed * 100;
                this.trail.push({ 
                    x: this.x, 
                    y: this.y, 
                    opacity: 1, 
                    size: Math.min(20, 5 + speedFactor * 1.5) // Slightly larger trail for visibility
                });
                if (this.trail.length > 20) this.trail.shift();
                this.trail.forEach(t => t.opacity -= 0.05);
            }

            draw() {
                const opacity = this.isHero || this.isModifier ? 1 : Math.max(0, this.health / (this.size * 2));
                ctx.save();
                if (this.charging || (gameState.score >= 100 && !this.isHero && !this.isModifier)) {
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.translate(-this.x, -this.y);
                }
                if (this.isHero) this.drawTrail();
                this.drawShape(opacity);
                if (this.isHero) this.drawActiveModifiers();
                ctx.restore();
            }

            drawTrail() {
                this.trail.forEach(point => {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, point.size * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(200, 200, 200, ${point.opacity * 0.2})`;
                    ctx.fill();
                });
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
                ctx.fill();
            }

            drawShape(opacity) {
                ctx.beginPath();
                if (this.type === 'circle') ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                else if (this.type === 'square') ctx.rect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
                else if (this.type === 'triangle') {
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.closePath();
                } else {
                    ctx.font = `${this.size * 2}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.type, this.x, this.y);
                }
                ctx.fillStyle = this.isHero || this.isModifier ?
                    `rgba(255, 255, 255, ${opacity})` :
                    this.color.replace(')', `, ${opacity})`).replace('hsl', 'hsla');
                ctx.fill();

                if (this.isModifier) {
                    ctx.strokeStyle = this.modifierColor;
                    ctx.lineWidth = Math.sin(Date.now() * 0.005) * 2 + 3;
                    ctx.stroke();
                } else if (this.shouldDrawAimAssist()) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 4;
                    ctx.stroke();
                }
                if (!this.isHero && !this.isModifier && this.marked) {
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.size, this.y - this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.moveTo(this.x + this.size, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            shouldDrawAimAssist() {
                if (!gameState.activeModifiers.some(mod => mod.type === 'üéØ') || this === gameState.hero) return false;
                return this.distanceTo(gameState.hero) < gameState.hero.size * 10;
            }

            drawActiveModifiers() {
                let offset = 0;
                gameState.activeModifiers.forEach(mod => {
                    ctx.beginPath();
                    ctx.arc(this.x + Math.cos(offset) * (this.size + 5), this.y + Math.sin(offset) * (this.size + 5), 10, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffffff';
                    ctx.fill();
                    ctx.font = '20px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = mod.modifierColor;
                    ctx.fillText(mod.type, this.x + Math.cos(offset) * (this.size + 5), this.y + Math.sin(offset) * (this.size + 5));
                    offset += Math.PI / 2;
                });
            }

            distanceTo(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            collidesWith(other) {
                return this.distanceTo(other) < (this.size + other.size);
            }

            combineWith(other) {
                if (this.size < this.maxSize) {
                    this.size = Math.min(this.maxSize, this.size + other.size * 0.5);
                    this.health = this.size * 2;
                }
            }
        }

        class Explosion {
            constructor(x, y, size, color) {
                this.x = x;
                this.y = y;
                this.size = size;
                this.maxSize = size * 2;
                this.color = color;
                this.life = 30;
                this.age = 0;
                this.particles = Array.from({ length: 10 }, () => ({
                    x: this.x,
                    y: this.y,
                    vx: (Math.random() - 0.5) * 6,
                    vy: (Math.random() - 0.5) * 6,
                    size: Math.random() * 5 + 2,
                    life: Math.random() * 20 + 10
                }));
            }

            update() {
                this.age++;
                this.size = this.maxSize * (1 - this.age / this.life);
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    p.size *= 0.95;
                });
                this.particles = this.particles.filter(p => p.life > 0);
            }

            draw() {
                const opacity = 1 - (this.age / this.life);
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace(')', `, ${opacity})`).replace('hsl', 'rgba');
                ctx.fill();

                this.particles.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, ${Math.random() * 100 + 100}, 0, ${p.life / 20})`;
                    ctx.fill();
                });
            }

            isDone() {
                return this.age >= this.life && this.particles.length === 0;
            }
        }

        // === Game Logic ===
        function drawEdgeFlash() {
            if (gameState.flash.timer > 0) {
                const edgeWidth = 20;
                const alpha = gameState.flash.timer / 10;
                ctx.fillStyle = gameState.flash.color.replace('0.5', alpha.toString());
                ctx.fillRect(0, 0, canvas.width, edgeWidth);
                ctx.fillRect(0, canvas.height - edgeWidth, canvas.width, edgeWidth);
                ctx.fillRect(0, 0, edgeWidth, canvas.height);
                ctx.fillRect(canvas.width - edgeWidth, 0, edgeWidth, canvas.height);
                gameState.flash.timer--;
            }
        }

        function updateUI() {
            scoreBox.textContent = `Score: ${gameState.score}`;
            const sortedShapes = Object.entries(gameState.stats)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3);
            shapeStats.innerHTML = 'Top Shapes: ' + sortedShapes.map(([type, count]) =>
                `<span class="shape-icon">${type === 'circle' ? '‚óè' : type === 'square' ? '‚ñ†' : '‚ñ≤'}</span>${count}`
            ).join(' ');
            updateBarGraph(shapeFreqCtx, shapeFreqCanvas, gameState.stats, { circle: '#ff9999', square: '#99ff99', triangle: '#9999ff' });
            updateBarGraph(colorFreqCtx, colorFreqCanvas, gameState.colorCounts); // Color frequency bar
        }

        function updateBarGraph(ctx, canvas, data, colors = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const total = Object.values(data).reduce((a, b) => a + b, 0) || 1;
            let x = 0;
            Object.entries(data).forEach(([key, count]) => {
                const width = (count / total) * canvas.width;
                ctx.fillStyle = colors ? colors[key] : key;
                ctx.fillRect(x, 0, width, canvas.height);
                x += width;
            });
        }

        function applyAimAssist() {
            gameState.shapes = gameState.shapes.filter(s => {
                if (s === gameState.hero || s.isModifier) return true;
                if (s.distanceTo(gameState.hero) < gameState.hero.size * 10) {
                    triggerCollision(s);
                    return false;
                }
                return true;
            });
        }

        function applyShield() {
            gameState.shapes.forEach(s => { if (s !== gameState.hero && !s.isModifier) s.marked = true; });
            setTimeout(() => {
                gameState.shapes = gameState.shapes.filter(s => {
                    if (s.marked) {
                        triggerCollision(s);
                        return false;
                    }
                    return true;
                });
            }, 500);
        }

        function triggerCollision(shape) {
            gameState.flash.timer = 10;
            gameState.flash.color = shape.color.replace(')', `, 0.5)`).replace('hsl', 'rgba'); // Pre-explosion color
            gameState.explosions.push(new Explosion(shape.x, shape.y, shape.size, shape.color));
            gameState.score++;
            gameState.stats[shape.type]++;
            gameState.colorCounts[shape.color] = (gameState.colorCounts[shape.color] || 0) + 1;
            updateUI();
        }

        function checkCollisions() {
            const toRemove = new Set();
            gameState.shapes.forEach((shape, i) => {
                if (shape.isHero) {
                    gameState.shapes.forEach((other, j) => {
                        if (i !== j && shape.collidesWith(other)) {
                            if (other.isModifier) {
                                gameState.activeModifiers.push({ ...other, timer: 600 });
                                toRemove.add(j);
                            } else {
                                triggerCollision(other);
                                toRemove.add(j);
                            }
                        }
                    });
                } else {
                    gameState.shapes.forEach((other, j) => {
                        if (i >= j || other.isHero) return;
                        if (shape.collidesWith(other) && !shape.isModifier && !other.isModifier) {
                            if (shape.type === other.type) {
                                shape.combineWith(other);
                                toRemove.add(j);
                            } else {
                                shape.health -= other.size;
                                other.health -= shape.size;
                                if (shape.health <= 0) toRemove.add(i);
                                if (other.health <= 0) toRemove.add(j);
                            }
                        }
                    });
                }
            });
            gameState.shapes = gameState.shapes.filter((_, i) => !toRemove.has(i));
            toRemove.forEach(i => {
                const shape = gameState.shapes[i];
                if (shape && !shape.isHero && !shape.isModifier && shape.health <= 0) {
                    gameState.explosions.push(new Explosion(shape.x, shape.y, shape.size, shape.color));
                }
            });
        }

        function awardModifiers() {
            const totalModifiers = Object.values(gameState.modifierCounts).reduce((a, b) => a + b, 0);
            if (gameState.score > 0 && gameState.score % 10 === 0 && totalModifiers < gameState.score / 10) {
                const modType = MODIFIER_TYPES[Math.floor(Math.random() * MODIFIER_TYPES.length)];
                gameState.modifierCounts[modType]++;
                modifierButtons[modType].textContent = `${modType}: ${gameState.modifierCounts[modType]}`;
            }
        }

        function activateRandomModifier() {
            const now = Date.now();
            if (now - gameState.lastModifierTime < 5000) return;
            const available = MODIFIER_TYPES.filter(t => gameState.modifierCounts[t] > 0);
            if (available.length === 0) return;
            const type = available[Math.floor(Math.random() * available.length)];
            activateModifier(type);
            gameState.lastModifierTime = now;
        }

        function activateModifier(type) {
            if (gameState.modifierCounts[type] <= 0) return;
            gameState.modifierCounts[type]--;
            const newMod = { type, modifierColor: MODIFIER_COLORS[type], timer: 600 };
            gameState.activeModifiers.push(newMod);
            if (type === 'üõ°Ô∏è') applyShield();
            modifierButtons[type].textContent = `${type}: ${gameState.modifierCounts[type]}`;
        }

        function spawnShapes(x, y) {
            for (let i = 0; i < 3; i++) {
                gameState.shapes.push(new Shape(false, false, x + (Math.random() - 0.5) * 50, y + (Math.random() - 0.5) * 50));
            }
        }

        // === Animation ===
        function animate() {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (Math.random() < gameState.settings.spawnRate && gameState.shapes.length < gameState.settings.maxShapes) {
                    gameState.shapes.push(new Shape());
                }
                gameState.shapes.forEach(s => { s.update(); s.draw(); });
                gameState.explosions.forEach(e => { e.update(); e.draw(); });
                gameState.explosions = gameState.explosions.filter(e => !e.isDone());
                gameState.shapes = gameState.shapes.filter(s => s.isHero || (s.age < s.life && s.health > 0));
                gameState.activeModifiers.forEach(m => {
                    m.timer--;
                    if (m.type === 'üéØ') applyAimAssist();
                });
                gameState.activeModifiers = gameState.activeModifiers.filter(m => m.timer > 0);
                checkCollisions();
                awardModifiers();
                activateRandomModifier();
                drawEdgeFlash();
                gameState.animationFrameId = requestAnimationFrame(animate);
            } catch (e) {
                console.error('Animation error:', e);
                resumeGame();
            }
        }

        // === UI Helpers ===
        function drawHelpScene() {
            helpCanvas.width = helpCanvas.clientWidth;
            helpCanvas.height = helpCanvas.clientHeight;
            helpCtx.clearRect(0, 0, helpCanvas.width, helpCanvas.height);
            helpCtx.beginPath();
            helpCtx.arc(helpCanvas.width / 2, helpCanvas.height / 2, 20, 0, Math.PI * 2);
            helpCtx.fillStyle = '#ffffff';
            helpCtx.fill();
            helpCtx.beginPath();
            helpCtx.arc(helpCanvas.width / 2 - 40, helpCanvas.height / 2 - 20, 15, 0, Math.PI * 2);
            helpCtx.fillStyle = 'hsl(0, 100%, 50%)';
            helpCtx.fill();
            helpCtx.beginPath();
            helpCtx.rect(helpCanvas.width / 2 + 25, helpCanvas.height / 2 - 20, 30, 30);
            helpCtx.fillStyle = 'hsl(120, 100%, 50%)';
            helpCtx.fill();
            helpCtx.beginPath();
            helpCtx.moveTo(helpCanvas.width / 2, helpCanvas.height / 2 + 30);
            helpCtx.lineTo(helpCanvas.width / 2 - 20, helpCanvas.height / 2 + 60);
            helpCtx.lineTo(helpCanvas.width / 2 + 20, helpCanvas.height / 2 + 60);
            helpCtx.closePath();
            helpCtx.fillStyle = 'hsl(240, 100%, 50%)';
            helpCtx.fill();
        }

        // === Game Controls ===
        function startGame() {
            resizeCanvas();
            canvas.style.display = 'block';
            startButton.style.display = 'none';
            gameUI.style.display = 'block';
            modifiersDiv.style.display = 'flex';
            helpButton.style.display = 'block';
            settingsButton.style.display = 'block';
            modeButton.style.display = 'block';
            copyright.style.display = 'block';
            gameState.hero = new Shape(true);
            gameState.shapes.push(gameState.hero);
            animate();
        }

        function pauseGame() {
            if (gameState.animationFrameId) {
                cancelAnimationFrame(gameState.animationFrameId);
                gameState.animationFrameId = null;
            }
        }

        function resumeGame() {
            if (!gameState.animationFrameId) {
                animate();
            }
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function toggleHelp() {
            helpText.style.display = helpText.style.display === 'block' ? 'none' : 'block';
            if (helpText.style.display === 'block') {
                drawHelpScene();
                pauseGame();
            } else {
                resumeGame();
            }
        }

        function toggleSettings() {
            settingsMenu.style.display = settingsMenu.style.display === 'block' ? 'none' : 'block';
            if (settingsMenu.style.display === 'block') pauseGame();
            else resumeGame();
        }

        function toggleMode() {
            gameState.mode = gameState.mode === 'auto' ? 'manual' : 'auto';
            modeButton.textContent = gameState.mode === 'auto' ? 'üéÆ' : 'ü§ñ';
            if (gameState.hero) {
                gameState.hero.vx = 0;
                gameState.hero.vy = 0;
            }
        }

        function saveSettings() {
            gameState.settings.spawnRate = parseFloat(settingsInputs.spawnRate.value);
            gameState.settings.heroSpeed = parseFloat(settingsInputs.heroSpeed.value);
            gameState.settings.maxShapes = parseInt(settingsInputs.maxShapes.value);
            gameState.settings.mouseSensitivity = parseFloat(settingsInputs.mouseSensitivity.value);
            gameState.hero.baseSpeed = gameState.settings.heroSpeed;
            settingsMenu.style.display = 'none';
            resumeGame();
        }

        // === Event Listeners ===
        startButton.addEventListener('click', startGame);
        Object.entries(modifierButtons).forEach(([type, button]) => {
            button.addEventListener('click', () => activateModifier(type));
        });
        helpButton.addEventListener('click', toggleHelp);
        settingsButton.addEventListener('click', toggleSettings);
        modeButton.addEventListener('click', toggleMode);
        saveSettingsButton.addEventListener('click', saveSettings);
        canvas.addEventListener('click', e => {
            if (canvas.style.display === 'block') spawnShapes(e.clientX, e.clientY);
        });
        canvas.addEventListener('mousemove', e => {
            gameState.mouseX = e.clientX;
            gameState.mouseY = e.clientY;
        });
        window.addEventListener('keydown', e => {
            gameState.keys.add(e.key.toLowerCase());
        });
        window.addEventListener('keyup', e => {
            gameState.keys.delete(e.key.toLowerCase());
        });
        window.addEventListener('resize', () => {
            if (canvas.style.display === 'block') resizeCanvas();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9271282d9b16bf6e',t:'MTc0MzEwMjMwMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>